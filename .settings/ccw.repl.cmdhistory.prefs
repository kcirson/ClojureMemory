cmdhistory=["(clojure.core/ns ClojureMemory.model)\\n(\:use ClojureMemory.model)\\n  (\:use clojure.test)\\n  (\:require [ClojureMemory.testdata \:as td]))\\n\\n(deftest get-board-cell-test\\n  (let [testboard [[\\\\X \\\\- \\\\-]\\n                   [\\\\- \\\\O \\\\-]\\n                   [\\\\- \\\\- \\\\X]]]\\n    (is (get-board-cell testboard 0 0) \\\\X)\\n    (is (get-board-cell testboard 0 1) \\\\-)\\n    (is (get-board-cell testboard 1 1) \\\\O)\\n    (is (get-board-cell testboard 2 2) \\\\X)))\\n\\n(deftest transposed-board-test\\n  (doseq [io-pair td/transposed-test-data]\\n    (is (transposed-board (\:input io-pair))\\n        (\:expected-output io-pair))))\\n\\n(defmacro defboardtest [name winfn positives negatives]\\n  `(deftest ~name\\n     (doseq [player\# [\\\\X \\\\O]]     \\n       (doseq [board\# (~positives player\#)]\\n         (is (\= (~winfn board\# player\#) true) \\n             (str \\"Player \\" player\# \\" should win with board \\" board\#)))\\n       (doseq [board\# (~negatives player\#)]\\n         (is (\= (~winfn board\# player\#) false)\\n             (str \\"Player \\" player\# \\" should not win with board \\" board\#))))))\\n\\n(defboardtest winner-in-rows?-test\\n              winner-in-rows?\\n              td/row-win-combinations\\n              td/no-row-win-combinations)\\n\\n(defboardtest winner-in-cols?-test\\n              winner-in-cols?\\n              td/col-win-combinations\\n              td/no-col-win-combinations)\\n\\n(defboardtest winner-in-diagonals?-test\\n              winner-in-diagonals?\\n              td/diag-win-combinations\\n              td/no-diag-win-combinations)\\n\\n(deftest full-board?-test\\n  (doseq [player [\\\\X \\\\O]]\\n    (doseq [board (td/full-boards player)]\\n      (is (\= (full-board? board) true)\\n          (str \\"Board should be considered full, but isn't\: \\" board)))\\n    (doseq [board (td/no-full-boards player)]\\n      (is (\= (full-board? board) false)\\n          (str \\"Board should not be considered full, but is\: \\" board)))))\\n\\n(deftest scenario1-test\\n  \\"it should not be possible to choose a cell that is already taken\\"\\n  (binding [noir.session/*noir-session* (atom {})]\\n    (reset-game\!)\\n    (play\! 0 0)\\n    (is (\= (get-board-cell 0 0) \\\\X))\\n    (play\! 0 1)\\n    (is (\= (get-board-cell 0 1) \\\\O))\\n    (play\! 0 2)\\n    (is (\= (get-board-cell 0 2) \\\\X))\\n    (is (\= (get-player) \\\\O))\\n    (play\! 0 0)\\n    (is (\= (get-board-cell 0 0) \\\\X) \\"value of cell 0 0 should still be X\\")\\n    (is (\= (get-player) \\\\O) \\"player should still be O\\")\\n    (reset-game\!)))\\n\\n;; exercise\: add deftest for function winner?\\n;; exercise\: macro for defining test scenarios which resets game automatically at beginning and end\\n;; exercise\: refactor scenario1-test using the macro\\n;; exercise\: more scenario's\\n;;       - player X wins\\n;;       - player O wins\\n;;       - it's a draw\\n\\n(clojure.core/ns user)" "(clojure.core/ns ClojureMemory.repl)\\n(ns ClojureMemory.repl\\n\\n(\:use ClojureMemory.handler\\n        ring.server.standalone\\n        [ring.middleware file-info file]))\\n(clojure.core/ns user)" "(clojure.core/ns ClojureMemory.repl)\\n(ns ClojureMemory.repl\\n\\n(\:use ClojureMemory.handler\\n        ring.server.standalone\\n        [ring.middleware file-info file]))\\n\\n(defonce server (atom nil))\\n\\n(defn get-handler []\\n  ;; \#'app expands to (var app) so that when we reload our code,\\n  ;; the server is forced to re-resolve the symbol in the var\\n  ;; rather than having its own copy. When the root binding\\n  ;; changes, the server picks it up without having to restart.\\n  (-> \#'app\\n    ; Makes static assets in $PROJECT_DIR/resources/public/ available.\\n    (wrap-file \\"resources\\")\\n    ; Content-Type, Content-Length, and Last Modified headers for files in body\\n    (wrap-file-info)))\\n\\n(defn start-server\\n  \\"used for starting the server in development mode from REPL\\"\\n  [& [port]]\\n  (let [port (if port (Integer/parseInt port) 8080)]\\n    (reset\! server\\n            (serve (get-handler)\\n                   {\:port port                   \\n                    \:auto-reload? true\\n                    \:join true}))\\n    (println (str \\"You can view the site at http\://localhost\:\\" port))))\\n\\n(defn stop-server []\\n  (.stop @server)\\n  (reset\! server nil))\\n\\n(clojure.core/ns user)" ";; Switching to ClojureMemory.view namespace" "hallo?" "(restart-agent)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n(defn winner-in-score?)\\n(clojure.core/ns ClojureMemory.repl)" ";; Switching to ClojureMemory.model namespace" "(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n" "(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n(session/put\! \:p1-score 10)\\n(session/put\! \:p2-score 20)\\n(checkWinner)" "(session/put\! \:p1-score 10)\\r\\n(session/put\! \:p2-score 20)\\n(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(session/put\! \:p1-score {10})\\r\\n(session/put\! \:p2-score {20})\\n(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(session/put\! \:p1-score 10)\\r\\n(session/put\! \:p2-score 20)\\n(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(session/put\! \:p1-score \:1 10)\\r\\n(session/put\! \:p2-score \:2 20)\\n(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)\\n" "(session/put\! \:p1-score [10])\\r\\n(session/put\! \:p2-score [20])\\n(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(defn checkWinner []\\n  (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n(session/put\! \:p1-score 10)\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(\:require [noir.session \:as session])\\n(session/put\! \:p1-score 10)\\r\\n(session/put\! \:p2-score 20)\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n(session/put\! \:p1-score 10)\\r\\n(session/put\! \:p2-score 20)\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})])\\n(session/put\! \:p1-score 10)\\r\\n(session/put\! \:p2-score 20)\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n" "(session/put\! \:p1-score 10)\\r\\n(session/put\! \:p2-score 20)\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})])\\n(session/put\! \:p1-score 10)\\r\\n(session/put\! \:p2-score 20)\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})])\\n(session/swap\! \:p1-score 10)\\r\\n(session/swap\! \:p2-score 20)\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})])\\n(session/put\! \:p1-score 10)\\n(session/get \:p1-score)\\n" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})])\\n(session/put\! \:p1-score (int 10))\\n\\r\\n(session/put\! \:p2-score (int 20))\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)\\n" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})])\\n(session/put\! {\:p1-score 10})\\n\\r\\n(session/put\! {\:p2-score 20})\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n\\n\\n(checkWinner)" "(checkIfEqual 1 10 10)\\n(defn checkIfEqual [player 1stVal 2ndVal]\\n  (if (\= 1stVal 2ndVal) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(checkIfEqual [1 10 10])\\n(defn checkIfEqual [player 1stVal 2ndVal]\\n  (if (\= 1stVal 2ndVal) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(checkIfEqual \\"1 10 10\\")\\n(defn checkIfEqual [player 1stVal 2ndVal]\\n  (if (\= 1stVal 2ndVal) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(checkIfEqual \\"1\\" \\"10\\" \\"10\\")\\n(defn checkIfEqual [player 1stVal 2ndVal]\\n  (if (\= 1stVal 2ndVal) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(checkIfEqual [1 10 10])\\n(defn checkIfEqual [player 1stVal 2ndVal]\\n  (if (\= 1stVal 2ndVal) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(checkIfEqual (1 10 10))\\n(defn checkIfEqual [player 1stVal 2ndVal]\\n  (if (\= 1stVal 2ndVal) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(checkIfEqual (1 10 10))\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(checkIfEqual 1 10 10)\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" ";; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 10 11)\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )" "(binding [sesh/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 10 10)\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 10 10)\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 10 10)\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n(checkWinner)\\n)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 10 10)\\n(session/put\! \:p2-score 4)\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n(checkWinner)\\n)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 10 10)\\n(session/put\! \:p2-score 4)\\n\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n(checkWinner)\\n)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 10 10)\\n(session/put\! \:p2-score 1)\\n\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n(checkWinner)\\n)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n(checkIfEqual 1 9 10)\\n(session/put\! \:p2-score 2)\\n\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n(checkWinner)\\n)" "(binding [session/*noir-session* (atom {\:somekey \\"somevalue\\"})]\\n;; Checkt of beide omgedraaide kaartjes gelijk zijn\\n  (session/put\! \:p1-score 0)\\n  (session/put\! \:p2-score 0)\\n(checkIfEqual 1 9 10)\\n(session/put\! \:p2-score 2)\\n\\n(defn checkIfEqual [player val1 val2]\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\n  \:else \\"Draai dingen terug\\"\\n  )\\n;; Switch user\\n(defn checkWinner []\\r\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\r\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\r\\n    \:else \\"Draw\!\\"\\r\\n    )\\r\\n  )\\n(checkWinner)\\n)" "(ns ClojureMemory.model\\n\\n  (\:use ClojureMemory.model)\\n  (\:use clojure.test)\\n  (\:require [ClojureMemory.testdata \:as td]))\\n\\n(deftest get-board-cell-test\\n  (let [testboard [[\\\\X \\\\- \\\\-]\\n                   [\\\\- \\\\O \\\\-]\\n                   [\\\\- \\\\- \\\\X]]]\\n    (is (get-board-cell testboard 0 0) \\\\X)\\n    (is (get-board-cell testboard 0 1) \\\\-)\\n    (is (get-board-cell testboard 1 1) \\\\O)\\n    (is (get-board-cell testboard 2 2) \\\\X)))\\n\\n(deftest transposed-board-test\\n  (doseq [io-pair td/transposed-test-data]\\n    (is (transposed-board (\:input io-pair))\\n        (\:expected-output io-pair))))\\n\\n(defmacro defboardtest [name winfn positives negatives]\\n  `(deftest ~name\\n     (doseq [player\# [\\\\X \\\\O]]     \\n       (doseq [board\# (~positives player\#)]\\n         (is (\= (~winfn board\# player\#) true) \\n             (str \\"Player \\" player\# \\" should win with board \\" board\#)))\\n       (doseq [board\# (~negatives player\#)]\\n         (is (\= (~winfn board\# player\#) false)\\n             (str \\"Player \\" player\# \\" should not win with board \\" board\#))))))\\n\\n(defboardtest winner-in-rows?-test\\n              winner-in-rows?\\n              td/row-win-combinations\\n              td/no-row-win-combinations)\\n\\n(defboardtest winner-in-cols?-test\\n              winner-in-cols?\\n              td/col-win-combinations\\n              td/no-col-win-combinations)\\n\\n(defboardtest winner-in-diagonals?-test\\n              winner-in-diagonals?\\n              td/diag-win-combinations\\n              td/no-diag-win-combinations)\\n\\n(deftest full-board?-test\\n  (doseq [player [\\\\X \\\\O]]\\n    (doseq [board (td/full-boards player)]\\n      (is (\= (full-board? board) true)\\n          (str \\"Board should be considered full, but isn't\: \\" board)))\\n    (doseq [board (td/no-full-boards player)]\\n      (is (\= (full-board? board) false)\\n          (str \\"Board should not be considered full, but is\: \\" board)))))\\n\\n(deftest scenario1-test\\n  \\"it should not be possible to choose a cell that is already taken\\"\\n  (binding [noir.session/*noir-session* (atom {})]\\n    (reset-game\!)\\n    (play\! 0 0)\\n    (is (\= (get-board-cell 0 0) \\\\X))\\n    (play\! 0 1)\\n    (is (\= (get-board-cell 0 1) \\\\O))\\n    (play\! 0 2)\\n    (is (\= (get-board-cell 0 2) \\\\X))\\n    (is (\= (get-player) \\\\O))\\n    (play\! 0 0)\\n    (is (\= (get-board-cell 0 0) \\\\X) \\"value of cell 0 0 should still be X\\")\\n    (is (\= (get-player) \\\\O) \\"player should still be O\\")\\n    (reset-game\!)))\\n\\n;; exercise\: add deftest for function winner?\\n;; exercise\: macro for defining test scenarios which resets game automatically at beginning and end\\n;; exercise\: refactor scenario1-test using the macro\\n;; exercise\: more scenario's\\n;;       - player X wins\\n;;       - player O wins\\n;;       - it's a draw\\n" "(ns ClojureMemory.model\\n\\n  (\:use ClojureMemory.model)\\n  (\:use clojure.test)\\n  (\:require [ClojureMemory.testdata \:as td]))\\n\\n(deftest get-board-cell-test\\n  (let [testboard [[\\\\X \\\\- \\\\-]\\n                   [\\\\- \\\\O \\\\-]\\n                   [\\\\- \\\\- \\\\X]]]\\n    (is (get-board-cell testboard 0 0) \\\\X)\\n    (is (get-board-cell testboard 0 1) \\\\-)\\n    (is (get-board-cell testboard 1 1) \\\\O)\\n    (is (get-board-cell testboard 2 3) \\\\X)))\\n\\n(deftest transposed-board-test\\n  (doseq [io-pair td/transposed-test-data]\\n    (is (transposed-board (\:input io-pair))\\n        (\:expected-output io-pair))))\\n\\n(defmacro defboardtest [name winfn positives negatives]\\n  `(deftest ~name\\n     (doseq [player\# [\\\\X \\\\O]]     \\n       (doseq [board\# (~positives player\#)]\\n         (is (\= (~winfn board\# player\#) true) \\n             (str \\"Player \\" player\# \\" should win with board \\" board\#)))\\n       (doseq [board\# (~negatives player\#)]\\n         (is (\= (~winfn board\# player\#) false)\\n             (str \\"Player \\" player\# \\" should not win with board \\" board\#))))))\\n\\n(defboardtest winner-in-rows?-test\\n              winner-in-rows?\\n              td/row-win-combinations\\n              td/no-row-win-combinations)\\n\\n(defboardtest winner-in-cols?-test\\n              winner-in-cols?\\n              td/col-win-combinations\\n              td/no-col-win-combinations)\\n\\n(defboardtest winner-in-diagonals?-test\\n              winner-in-diagonals?\\n              td/diag-win-combinations\\n              td/no-diag-win-combinations)\\n\\n(deftest full-board?-test\\n  (doseq [player [\\\\X \\\\O]]\\n    (doseq [board (td/full-boards player)]\\n      (is (\= (full-board? board) true)\\n          (str \\"Board should be considered full, but isn't\: \\" board)))\\n    (doseq [board (td/no-full-boards player)]\\n      (is (\= (full-board? board) false)\\n          (str \\"Board should not be considered full, but is\: \\" board)))))\\n\\n(deftest scenario1-test\\n  \\"it should not be possible to choose a cell that is already taken\\"\\n  (binding [noir.session/*noir-session* (atom {})]\\n    (reset-game\!)\\n    (play\! 0 0)\\n    (is (\= (get-board-cell 0 0) \\\\X))\\n    (play\! 0 1)\\n    (is (\= (get-board-cell 0 1) \\\\O))\\n    (play\! 0 2)\\n    (is (\= (get-board-cell 0 2) \\\\X))\\n    (is (\= (get-player) \\\\O))\\n    (play\! 0 0)\\n    (is (\= (get-board-cell 0 0) \\\\X) \\"value of cell 0 0 should still be X\\")\\n    (is (\= (get-player) \\\\O) \\"player should still be O\\")\\n    (reset-game\!)))\\n\\n;; exercise\: add deftest for function winner?\\n;; exercise\: macro for defining test scenarios which resets game automatically at beginning and end\\n;; exercise\: refactor scenario1-test using the macro\\n;; exercise\: more scenario's\\n;;       - player X wins\\n;;       - player O wins\\n;;       - it's a draw\\n" ";; Switching to ClojureMemory.repl namespace" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n(get-board-value 0 0)\\n(clojure.core/ns ClojureMemory.repl)" ";; Switching to ClojureMemory.repl namespace" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'ClojureMemory.repl)))" "(start-server)" "(asdf)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(ClojureMemory.model/reset-game\!)" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn reset-game\! []\\n  (session/put\! \:game-state init-state)\\n  (do (println (session/get \:game-state))))\\n(clojure.core/ns ClojureMemory.repl)" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n(def init-state {\:board empty-board \:memoryboard memory-board \:choicenumb 0 \:temprow 0 \:tempcol 0 \:p1-score 0 \:p2-score 0 \:player \\\\X})\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(do (println (session/get \:game-state))) (println (session/get \:choicenumb)))\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(defn play\! [row col]\\n  (do (println (session/get \:game-state))) (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) nil)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(do (println (session/get \:game-state)) (println (session/get \:choicenumb)))\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(defn play\! [row col]\\n  (do (println (session/get \:game-state)) (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) nil)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn play\! [row col]\\n  (do (println (session/get \:game-state)))\\n  (cond \\n    (\= (session/get \:choicenumb) 0)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn play\! [row col]\\n  (cond \\n    (\= (session/get \:choicenumb) 0)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(start-server)" "(stop-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n(defn play\! [row col]\\n  (do (cond \\n    (\= (session/get \:choicenumb) 0)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  ))\\n\\n(clojure.core/ns ClojureMemory.repl)" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn play\! [row col]\\n  (do (println (session/get \:game-state)))\\n  (cond \\n    (\= (session/get \:choicenumb) 0)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn play\! [row col]\\n  (do (println (session/get \:game-state)) (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) 0)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn play\! [row col]\\n  (do (println (session/get \:game-state)) (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) nil)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(defn play\! [row col]\\n  (do (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) nil)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n\\n(clojure.core/ns ClojureMemory.repl)" "(stop-server)" "(start-server)" "(stop-server)" "(clojure.core/ns ClojureMemory.model)\\n(ns ClojureMemory.model\\n\\n(\:require [noir.session \:as session]))\\n\\n(def empty-board [[\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]])\\n\\n(def memory-board [[\\\\A \\\\B \\\\D \\\\E \\\\C]\\r\\n                  [\\\\A \\\\B \\\\C \\\\F \\\\G]\\r\\n                  [\\\\D \\\\G \\\\H \\\\J \\\\I]\\n                  [\\\\E \\\\F \\\\I \\\\J \\\\H]])\\n\\n(def init-state {\:board empty-board \:memoryboard memory-board \:choicenumb 0 \:temprow 0 \:tempcol 0 \:p1-score 0 \:p2-score 0 \:player \\\\X})\\n\\n(defn reset-game\! []\\n  (session/put\! \:game-state init-state))\\n  \\n\\n(defn get-board []\\n  (\:board (session/get \:game-state)))\\n\\n(defn get-memoryboard []\\r\\n  (\:memoryboard (session/get \:game-state)))\\n\\n(defn get-board-cell \\n  ([row col]\\n    (get-board-cell (get-board) row col))\\n  ([board row col]\\n    (get-in board [row col])))\\n\\n(defn get-board-value \\r\\n   ([row col]\\r\\n    (get-board-value (get-memoryboard) row col))\\r\\n  ([board row col]\\r\\n    (get-in board [row col]))\\r\\n  )\\n\\n(defn get-player []\\n  (\:player (session/get \:game-state)))\\n\\n(defn other-player \\n  ([] (other-player (get-player)))\\n  ([player] (if (\= player \\\\X) \\\\O \\\\X))) \\n\\n(defn checkIfEqual? [player val1 val2]\\r\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\r\\n   (other-player(\:player player))\\r\\n  )\\n\\n(defn winner-in-rows? [board player]\\n  (boolean (some (fn [row] (every? (fn [c] (\= c player)) row)) board)))\\n\\n(defn transposed-board [board]\\n  (vec (apply map vector board)))\\n\\n(defn winner-in-cols? [board player]\\n  (winner-in-rows? (transposed-board board) player))\\n\\n(defn winner-in-diagonals? [board player]\\n  (let [diag-coords [[[0 0] [1 1] [2 2]]\\n                     [[0 2] [1 1] [2 0]]]]\\n    (boolean (some (fn [coords] \\n                     (every? (fn [coord] \\n                               (\= player (apply get-board-cell board coord))) \\n                             coords))\\n                   diag-coords))))\\n\\n;;Change to only check when game has ended.\\n(defn winner?\\n  \\"checks if there is a winner. when called with no args, checks for player X and player O.\\nreturns the character for the winning player, nil if there is no winner\\"\\n  ([] (winner? (get-board)))\\n  ([board]\\n    (boolean (or (winner? board \\\\X)\\n                 (winner? board \\\\O))))\\n  ([board player]\\n    (if (or (winner-in-rows? board player)\\n            (winner-in-cols? board player)\\n            (winner-in-diagonals? board player))\\n      player)))\\n\\n(defn full-board?\\n  ([] (full-board? (get-board)))\\n  ([board] (let [all-cells (apply concat board)]\\n             (not-any? \#(\= % \\\\-) all-cells))))\\n\\n(defn new-state [row col old-state]\\n  (if (and (\= (get-board-cell (\:board old-state) row col) \\\\-)\\n           (not (winner? (\:board old-state))))\\n    {\:board (assoc-in (\:board old-state) [row col] (get-board-value row col))\\n     \:player (\:player old-state)\\n     \:memoryboard (get-memoryboard)\\n     \:choicenumb (\:choicenumb old-state)\\n     \:temprow (\:temprow old-state)\\n     \:tempcol (\:tempcol old-state)\\n     \:p1-score (\:p1-score old-state)\\n     \:p2-score (\:p2-score old-state)\\n     }\\n    old-state))\\n\\n(defn reverse-state [row col old-state]\\r\\n  (if (and (\= (get-board-cell (\:board old-state) row col) \\\\-)\\r\\n           (not (winner? (\:board old-state))))\\r\\n    {\:board (assoc-in (\:board old-state) [row col] \\\\-)\\r\\n     \:player (other-player (\:player old-state))\\r\\n     \:memoryboard (get-memoryboard)\\n     \:choicenumb (\:choicenumb old-state)\\r\\n     \:temprow (\:temprow old-state)\\r\\n     \:tempcol (\:tempcol old-state)\\r\\n     \:p1-score (\:p1-score old-state)\\r\\n     \:p2-score (\:p2-score old-state)\\n     }\\r\\n    old-state))\\n\\n(defn hideValues [row col]\\r\\n  (session/swap\! \\r\\n          (fn [session-map] (assoc session-map \:game-state (reverse-state row col (\:game-state session-map))))\\r\\n  ))\\n\\n(defn play\! [row col]\\n  (do (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) nil)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n(ns ClojureMemory.model\\n\\n(\:require [noir.session \:as session]))\\n\\n(def empty-board [[\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]])\\n\\n(def memory-board [[\\\\A \\\\B \\\\D \\\\E \\\\C]\\r\\n                  [\\\\A \\\\B \\\\C \\\\F \\\\G]\\r\\n                  [\\\\D \\\\G \\\\H \\\\J \\\\I]\\n                  [\\\\E \\\\F \\\\I \\\\J \\\\H]])\\n\\n(def init-state {\:board empty-board \:memoryboard memory-board \:choicenumb 0 \:temprow 0 \:tempcol 0 \:p1-score 0 \:p2-score 0 \:player \\\\X})\\n\\n(defn reset-game\! []\\n  (session/put\! \:game-state init-state)\\n  (do(println (session/get \:game-state)))\\n  \\n\\n(defn get-board []\\n  (\:board (session/get \:game-state)))\\n\\n(defn get-memoryboard []\\r\\n  (\:memoryboard (session/get \:game-state)))\\n\\n(defn get-board-cell \\n  ([row col]\\n    (get-board-cell (get-board) row col))\\n  ([board row col]\\n    (get-in board [row col])))\\n\\n(defn get-board-value \\r\\n   ([row col]\\r\\n    (get-board-value (get-memoryboard) row col))\\r\\n  ([board row col]\\r\\n    (get-in board [row col]))\\r\\n  )\\n\\n(defn get-player []\\n  (\:player (session/get \:game-state)))\\n\\n(defn other-player \\n  ([] (other-player (get-player)))\\n  ([player] (if (\= player \\\\X) \\\\O \\\\X))) \\n\\n(defn checkIfEqual? [player val1 val2]\\r\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\r\\n   (other-player(\:player player))\\r\\n  )\\n\\n(defn winner-in-rows? [board player]\\n  (boolean (some (fn [row] (every? (fn [c] (\= c player)) row)) board)))\\n\\n(defn transposed-board [board]\\n  (vec (apply map vector board)))\\n\\n(defn winner-in-cols? [board player]\\n  (winner-in-rows? (transposed-board board) player))\\n\\n(defn winner-in-diagonals? [board player]\\n  (let [diag-coords [[[0 0] [1 1] [2 2]]\\n                     [[0 2] [1 1] [2 0]]]]\\n    (boolean (some (fn [coords] \\n                     (every? (fn [coord] \\n                               (\= player (apply get-board-cell board coord))) \\n                             coords))\\n                   diag-coords))))\\n\\n;;Change to only check when game has ended.\\n(defn winner?\\n  \\"checks if there is a winner. when called with no args, checks for player X and player O.\\nreturns the character for the winning player, nil if there is no winner\\"\\n  ([] (winner? (get-board)))\\n  ([board]\\n    (boolean (or (winner? board \\\\X)\\n                 (winner? board \\\\O))))\\n  ([board player]\\n    (if (or (winner-in-rows? board player)\\n            (winner-in-cols? board player)\\n            (winner-in-diagonals? board player))\\n      player)))\\n\\n(defn full-board?\\n  ([] (full-board? (get-board)))\\n  ([board] (let [all-cells (apply concat board)]\\n             (not-any? \#(\= % \\\\-) all-cells))))\\n\\n(defn new-state [row col old-state]\\n  (if (and (\= (get-board-cell (\:board old-state) row col) \\\\-)\\n           (not (winner? (\:board old-state))))\\n    {\:board (assoc-in (\:board old-state) [row col] (get-board-value row col))\\n     \:player (\:player old-state)\\n     \:memoryboard (get-memoryboard)\\n     \:choicenumb (\:choicenumb old-state)\\n     \:temprow (\:temprow old-state)\\n     \:tempcol (\:tempcol old-state)\\n     \:p1-score (\:p1-score old-state)\\n     \:p2-score (\:p2-score old-state)\\n     }\\n    old-state))\\n\\n(defn reverse-state [row col old-state]\\r\\n  (if (and (\= (get-board-cell (\:board old-state) row col) \\\\-)\\r\\n           (not (winner? (\:board old-state))))\\r\\n    {\:board (assoc-in (\:board old-state) [row col] \\\\-)\\r\\n     \:player (other-player (\:player old-state))\\r\\n     \:memoryboard (get-memoryboard)\\n     \:choicenumb (\:choicenumb old-state)\\r\\n     \:temprow (\:temprow old-state)\\r\\n     \:tempcol (\:tempcol old-state)\\r\\n     \:p1-score (\:p1-score old-state)\\r\\n     \:p2-score (\:p2-score old-state)\\n     }\\r\\n    old-state))\\n\\n(defn hideValues [row col]\\r\\n  (session/swap\! \\r\\n          (fn [session-map] (assoc session-map \:game-state (reverse-state row col (\:game-state session-map))))\\r\\n  ))\\n\\n(defn play\! [row col]\\n  (do (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) nil)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )\\n(clojure.core/ns ClojureMemory.repl)" "(ns ClojureMemory.model\\n\\n(\:require [noir.session \:as session]))\\n\\n(def empty-board [[\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]\\n                  [\\\\- \\\\- \\\\- \\\\- \\\\-]])\\n\\n(def memory-board [[\\\\A \\\\B \\\\D \\\\E \\\\C]\\r\\n                  [\\\\A \\\\B \\\\C \\\\F \\\\G]\\r\\n                  [\\\\D \\\\G \\\\H \\\\J \\\\I]\\n                  [\\\\E \\\\F \\\\I \\\\J \\\\H]])\\n\\n(def init-state {\:board empty-board \:memoryboard memory-board \:choicenumb 0 \:temprow 0 \:tempcol 0 \:p1-score 0 \:p2-score 0 \:player \\\\X})\\n\\n(defn reset-game\! []\\n  (session/put\! \:game-state init-state)\\n  (do(println (session/get \:game-state))))\\n  \\n\\n(defn get-board []\\n  (\:board (session/get \:game-state)))\\n\\n(defn get-memoryboard []\\r\\n  (\:memoryboard (session/get \:game-state)))\\n\\n(defn get-board-cell \\n  ([row col]\\n    (get-board-cell (get-board) row col))\\n  ([board row col]\\n    (get-in board [row col])))\\n\\n(defn get-board-value \\r\\n   ([row col]\\r\\n    (get-board-value (get-memoryboard) row col))\\r\\n  ([board row col]\\r\\n    (get-in board [row col]))\\r\\n  )\\n\\n(defn get-player []\\n  (\:player (session/get \:game-state)))\\n\\n(defn other-player \\n  ([] (other-player (get-player)))\\n  ([player] (if (\= player \\\\X) \\\\O \\\\X))) \\n\\n(defn checkIfEqual? [player val1 val2]\\r\\n  (if (\= val1 val2) (session/put\! \:p1-score 2))\\r\\n   (other-player(\:player player))\\r\\n  )\\n\\n(defn winner-in-rows? [board player]\\n  (boolean (some (fn [row] (every? (fn [c] (\= c player)) row)) board)))\\n\\n(defn transposed-board [board]\\n  (vec (apply map vector board)))\\n\\n(defn winner-in-cols? [board player]\\n  (winner-in-rows? (transposed-board board) player))\\n\\n(defn winner-in-diagonals? [board player]\\n  (let [diag-coords [[[0 0] [1 1] [2 2]]\\n                     [[0 2] [1 1] [2 0]]]]\\n    (boolean (some (fn [coords] \\n                     (every? (fn [coord] \\n                               (\= player (apply get-board-cell board coord))) \\n                             coords))\\n                   diag-coords))))\\n\\n;;Change to only check when game has ended.\\n(defn winner?\\n  \\"checks if there is a winner. when called with no args, checks for player X and player O.\\nreturns the character for the winning player, nil if there is no winner\\"\\n  ([] (winner? (get-board)))\\n  ([board]\\n    (boolean (or (winner? board \\\\X)\\n                 (winner? board \\\\O))))\\n  ([board player]\\n    (if (or (winner-in-rows? board player)\\n            (winner-in-cols? board player)\\n            (winner-in-diagonals? board player))\\n      player)))\\n\\n(defn full-board?\\n  ([] (full-board? (get-board)))\\n  ([board] (let [all-cells (apply concat board)]\\n             (not-any? \#(\= % \\\\-) all-cells))))\\n\\n(defn new-state [row col old-state]\\n  (if (and (\= (get-board-cell (\:board old-state) row col) \\\\-)\\n           (not (winner? (\:board old-state))))\\n    {\:board (assoc-in (\:board old-state) [row col] (get-board-value row col))\\n     \:player (\:player old-state)\\n     \:memoryboard (get-memoryboard)\\n     \:choicenumb (\:choicenumb old-state)\\n     \:temprow (\:temprow old-state)\\n     \:tempcol (\:tempcol old-state)\\n     \:p1-score (\:p1-score old-state)\\n     \:p2-score (\:p2-score old-state)\\n     }\\n    old-state))\\n\\n(defn reverse-state [row col old-state]\\r\\n  (if (and (\= (get-board-cell (\:board old-state) row col) \\\\-)\\r\\n           (not (winner? (\:board old-state))))\\r\\n    {\:board (assoc-in (\:board old-state) [row col] \\\\-)\\r\\n     \:player (other-player (\:player old-state))\\r\\n     \:memoryboard (get-memoryboard)\\n     \:choicenumb (\:choicenumb old-state)\\r\\n     \:temprow (\:temprow old-state)\\r\\n     \:tempcol (\:tempcol old-state)\\r\\n     \:p1-score (\:p1-score old-state)\\r\\n     \:p2-score (\:p2-score old-state)\\n     }\\r\\n    old-state))\\n\\n(defn hideValues [row col]\\r\\n  (session/swap\! \\r\\n          (fn [session-map] (assoc session-map \:game-state (reverse-state row col (\:game-state session-map))))\\r\\n  ))\\n\\n(defn play\! [row col]\\n  (do (println (session/get \:choicenumb)))\\n  (cond \\n    (\= (session/get \:choicenumb) nil)\\n      (do (session/put\! \:temprow row)\\n       (session/put\! \:tempcol col)\\n       (session/put\! \:choicenumb 1) \\n       (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\n    (\= (session/get \:choicenumb) 1)\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\n      (hideValues row col)\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\n      )\\n    )\\n  )\\n\\n(defn checkWinner []\\n (cond (> (session/get \:p1-score) (session/get \:p2-score)) \\"Player 1 won\\"\\n    (< (session/get \:p1-score) (session/get \:p2-score)) \\"Player 2 won\\"\\n    \:else \\"Draw\!\\"\\n    )\\n  )" "(clojure.core/ns ClojureMemory.repl)\\n(ns ClojureMemory.repl\\n\\n(\:use ClojureMemory.handler\\n        ring.server.standalone\\n        [ring.middleware file-info file]))\\n\\n(defonce server (atom nil))\\n\\n(defn get-handler []\\n  ;; \#'app expands to (var app) so that when we reload our code,\\n  ;; the server is forced to re-resolve the symbol in the var\\n  ;; rather than having its own copy. When the root binding\\n  ;; changes, the server picks it up without having to restart.\\n  (-> \#'app\\n    ; Makes static assets in $PROJECT_DIR/resources/public/ available.\\n    (wrap-file \\"resources\\")\\n    ; Content-Type, Content-Length, and Last Modified headers for files in body\\n    (wrap-file-info)))\\n\\n(defn start-server\\n  \\"used for starting the server in development mode from REPL\\"\\n  [& [port]]\\n  (let [port (if port (Integer/parseInt port) 8080)]\\n    (reset\! server\\n            (serve (get-handler)\\n                   {\:port port                   \\n                    \:auto-reload? true\\n                    \:join true}))\\n    (println (str \\"You can view the site at http\://localhost\:\\" port))))\\n\\n(defn stop-server []\\n  (.stop @server)\\n  (reset\! server nil))\\n(clojure.core/ns ClojureMemory.model)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n(defn play\!\\r\\n  ([row col]\\r\\n    (session/put\! \:temprow row)\\r\\n    (session/put\! \:tempcol col)\\r\\n    (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\r\\n  ([row col second] \\r\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\r\\n      (hideValues row col)\\r\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\r\\n      )))\\n(clojure.core/ns ClojureMemory.repl)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn play\!\\r\\n  ([row col]\\r\\n    (session/put\! \:temprow row)\\r\\n    (session/put\! \:tempcol col)\\r\\n    (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map))))))\\r\\n  ([row col second] \\r\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\r\\n      (hideValues row col)\\r\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\r\\n      )))\\n(clojure.core/ns ClojureMemory.repl)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n(defn get-turn []\\n  (\:turn (session/get \:game-state)))\\n\\n(clojure.core/ns ClojureMemory.repl)" "(stop-server)" "(start-server)" "(clojure.core/ns ClojureMemory.model)\\n\\n(defn play\!\\r\\n  ([row col]\\r\\n    (do (session/put\! \:temprow row)\\r\\n    (session/put\! \:tempcol col)\\n    (session/put\! \:turn 2)\\r\\n    (session/swap\! (fn [session-map] (assoc session-map \:game-state (new-state row col (\:game-state session-map)))))))\\n  ([row col second] \\r\\n    (if(checkIfEqual? (get-player) (get-board-value row col) (get-board-value (session/get \:temprow) (session/get \:tempcol)))\\r\\n      (do ((session/put\! \:turn 1)\\n      (hideValues row col)\\r\\n      (hideValues (session/get \:temprow) (session/get \:tempcol))\\r\\n      )))))\\n(clojure.core/ns ClojureMemory.repl)" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'ClojureMemory.controller)))" ";; Switching to ClojureMemory.controller namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "set-agent-send-off-executor\!" "set-agent-send-executor\!" "(stop-server)" "(start-server)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'ClojureMemory.model)))" "(stop-server)" "(start-server)" "hallo?" "(stop-server)" "(start-server)" "(stop-server)" "(start-server)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'ClojureMemory.model)))" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(stop-server)" "(start-server)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'ClojureMemory.view)))" ";; Switching to ClojureMemory.repl namespace" "(start-server)" "(stop-server)" "(start-server)" "stop-server" "(stop-server)" "(start-server)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'ClojureMemory.controller)))" "(clojure.core/ns ClojureMemory.model)\\n(deftest get-board-cell-test\\r\\n  (let [testboard [[\\\\A \\\\B \\\\D \\\\E \\\\C]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\A \\\\B \\\\C \\\\F \\\\G]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\D \\\\G \\\\H \\\\J \\\\I]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\E \\\\F \\\\I \\\\J \\\\H]]\\r\\n    (is (get-board-cell testboard 0 0) \\\\A)\\r\\n    (is (get-board-cell testboard 0 1) \\\\B)\\r\\n    (is (get-board-cell testboard 1 1) \\\\A)\\r\\n    (is (get-board-cell testboard 2 3) \\\\J))\\n)\\n\\n\\n(clojure.core/ns ClojureMemory.repl)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" ";; Switching to ClojureMemory.model namespace" "(deftest get-board-cell-test\\r\\n  (let [testboard [[\\\\A \\\\B \\\\D \\\\E \\\\C]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\A \\\\B \\\\C \\\\F \\\\G]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\D \\\\G \\\\H \\\\J \\\\I]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\E \\\\F \\\\I \\\\J \\\\H]]]\\r\\n    (is (get-board-cell testboard 0 0) \\\\A)\\r\\n    (is (get-board-cell testboard 0 1) \\\\B)\\r\\n    (is (get-board-cell testboard 1 1) \\\\A)\\r\\n    (is (get-board-cell testboard 2 3) \\\\J))\\n)\\n" "(get-board-cell-test)" "(deftest get-board-cell-test\\r\\n  (let [testboard [[\\\\A \\\\B \\\\D \\\\E \\\\C]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\A \\\\B \\\\C \\\\F \\\\G]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\D \\\\G \\\\H \\\\J \\\\I]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\E \\\\F \\\\I \\\\J \\\\H]]]\\r\\n    (is (get-board-cell testboard 0 0) \\\\A)\\r\\n    (is (get-board-cell testboard 0 1) \\\\B)\\r\\n    (is (get-board-cell testboard 1 1) \\\\A)\\r\\n    (is (get-board-cell testboard 2 3) \\\\H))\\n)" "(get-board-cell-test)" "(test testmodel.clj)" ";; Switching to ClojureMemory.testmodel namespace" "(test ClojureMemory.testmodel)" "(test ClojureMemory.testdata)" "lein test" "(test-all-vars ClojureMemory.testdata)" "(run-tests ClojureMemory.testmodel)" "(run-tests ClojureMemory.test.testmodel)" ";; Switching to ClojureMemory.testmodel namespace" "(run-all-tests)" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.testmodel namespace" "(run-tests)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.testmodel namespace" "(run-tests)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.testmodel namespace" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.testmodel namespace" "(deftest get-board-cell-test\\r\\n  (let [testboard [[\\\\A \\\\B \\\\D \\\\E \\\\C]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\A \\\\B \\\\C \\\\F \\\\G]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\D \\\\G \\\\H \\\\J \\\\I]\\r\\n\\t\\t\\t\\t\\t\\t\\t     [\\\\E \\\\F \\\\I \\\\J \\\\H]]]\\r\\n    (is (\= (get-board-cell testboard 0 0) \\\\A))\\r\\n    (is (\= (get-board-cell testboard 0 1) \\\\B))\\r\\n    (is (\= (get-board-cell testboard 1 1) \\\\B))\\r\\n    (is (\= (get-board-cell testboard 2 3) \\\\J)))\\n)" "(get-board-cell-test)" "(run-tests)" "(deftest full-board-test\\n  (is (full-board? td/full-board) true)\\n)" "(run-tests)" "(deftest full-board-test\\n  (is (full-board? (td/full-board)) true)\\n)" "(run-tests)" "(deftest checkIfEqualTest\\n  (is (checkIfEqual? /1 (get-board-cell (td/combination) 0 0) (get-board-cell (td/combination) 1 0) true))\\n)\\n" "(run-tests)" "(deftest checkIfEqualTest\\n  (binding [noir.session/*noir-session* (atom {})]\\n  (is (checkIfEqual? \\\\1 (get-board-cell (td/combination) 0 0) (get-board-cell (td/combination) 1 0)) true)\\n  (is (checkIfEqual? \\\\1 (get-board-cell (td/combination) 0 0) (get-board-cell (td/combination) 0 1)) false)\\n  )\\n)" "(run-tests)" ";; Switching to ClojureMemory.model namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)" ";; Switching to ClojureMemory.view namespace" ";; Switching to ClojureMemory.repl namespace" "(start-server)"]
eclipse.preferences.version=1
